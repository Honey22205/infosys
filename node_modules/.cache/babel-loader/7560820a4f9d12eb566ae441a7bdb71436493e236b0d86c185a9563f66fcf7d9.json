{"ast":null,"code":"class TranscriptService {\n  constructor() {\n    this.segments = [];\n    this.currentTime = 0;\n    this.listeners = [];\n    this.timeOffset = 0;\n  }\n  setTranscript(transcript) {\n    this.segments = this.parseTranscript(transcript);\n    this.timeOffset = 0;\n    this.updateListeners();\n  }\n  parseTranscript(transcript) {\n    return transcript.split('\\n').filter(line => line.trim()).map(line => {\n      const match = line.match(/\\[(\\d{2}):(\\d{2})\\](.*)/);\n      if (match) {\n        const minutes = parseInt(match[1]);\n        const seconds = parseInt(match[2]);\n        const text = match[3].trim();\n        const start = minutes * 60 + seconds;\n        const duration = text.length * 0.06 + 2; // Estimate duration based on text length\n        return {\n          text,\n          start,\n          end: start + duration\n        };\n      }\n      return null;\n    }).filter(segment => segment !== null);\n  }\n  updateTime(time) {\n    this.currentTime = time;\n    const adjustedTime = time + this.timeOffset;\n    this.updateListeners();\n  }\n  getCurrentSegment() {\n    return this.segments.find(segment => this.currentTime >= segment.start && this.currentTime <= segment.end) || null;\n  }\n  getNextSegment() {\n    return this.segments.find(segment => this.currentTime < segment.start) || null;\n  }\n  getPreviousSegment() {\n    return [...this.segments].reverse().find(segment => this.currentTime > segment.end) || null;\n  }\n  addListener(listener) {\n    this.listeners.push(listener);\n    listener(this.getCurrentSegment());\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n  updateListeners() {\n    const currentSegment = this.getCurrentSegment();\n    this.listeners.forEach(listener => listener(currentSegment));\n  }\n  setTimeOffset(offset) {\n    this.timeOffset = offset;\n    this.updateListeners();\n  }\n  getAllSegments() {\n    return [...this.segments];\n  }\n}\nexport const transcriptService = new TranscriptService();","map":{"version":3,"names":["TranscriptService","constructor","segments","currentTime","listeners","timeOffset","setTranscript","transcript","parseTranscript","updateListeners","split","filter","line","trim","map","match","minutes","parseInt","seconds","text","start","duration","length","end","segment","updateTime","time","adjustedTime","getCurrentSegment","find","getNextSegment","getPreviousSegment","reverse","addListener","listener","push","l","currentSegment","forEach","setTimeOffset","offset","getAllSegments","transcriptService"],"sources":["C:/Users/BIT/OneDrive/Desktop/infosts/src/services/transcriptService.ts"],"sourcesContent":["interface TranscriptSegment {\r\n  text: string;\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\ntype TranscriptListener = (segment: TranscriptSegment | null) => void;\r\n\r\nclass TranscriptService {\r\n  private segments: TranscriptSegment[] = [];\r\n  private currentTime: number = 0;\r\n  private listeners: TranscriptListener[] = [];\r\n  private timeOffset: number = 0;\r\n\r\n  setTranscript(transcript: string) {\r\n    this.segments = this.parseTranscript(transcript);\r\n    this.timeOffset = 0;\r\n    this.updateListeners();\r\n  }\r\n\r\n  private parseTranscript(transcript: string): TranscriptSegment[] {\r\n    return transcript\r\n      .split('\\n')\r\n      .filter(line => line.trim())\r\n      .map(line => {\r\n        const match = line.match(/\\[(\\d{2}):(\\d{2})\\](.*)/);\r\n        if (match) {\r\n          const minutes = parseInt(match[1]);\r\n          const seconds = parseInt(match[2]);\r\n          const text = match[3].trim();\r\n          const start = minutes * 60 + seconds;\r\n          const duration = text.length * 0.06 + 2; // Estimate duration based on text length\r\n          return {\r\n            text,\r\n            start,\r\n            end: start + duration\r\n          };\r\n        }\r\n        return null;\r\n      })\r\n      .filter((segment): segment is TranscriptSegment => segment !== null);\r\n  }\r\n\r\n  updateTime(time: number) {\r\n    this.currentTime = time;\r\n    const adjustedTime = time + this.timeOffset;\r\n    this.updateListeners();\r\n  }\r\n\r\n  private getCurrentSegment(): TranscriptSegment | null {\r\n    return this.segments.find(segment =>\r\n      this.currentTime >= segment.start && this.currentTime <= segment.end\r\n    ) || null;\r\n  }\r\n\r\n  private getNextSegment(): TranscriptSegment | null {\r\n    return this.segments.find(segment =>\r\n      this.currentTime < segment.start\r\n    ) || null;\r\n  }\r\n\r\n  private getPreviousSegment(): TranscriptSegment | null {\r\n    return [...this.segments]\r\n      .reverse()\r\n      .find(segment => this.currentTime > segment.end) || null;\r\n  }\r\n\r\n  addListener(listener: TranscriptListener): () => void {\r\n    this.listeners.push(listener);\r\n    listener(this.getCurrentSegment());\r\n    return () => {\r\n      this.listeners = this.listeners.filter(l => l !== listener);\r\n    };\r\n  }\r\n\r\n  private updateListeners() {\r\n    const currentSegment = this.getCurrentSegment();\r\n    this.listeners.forEach(listener => listener(currentSegment));\r\n  }\r\n\r\n  setTimeOffset(offset: number) {\r\n    this.timeOffset = offset;\r\n    this.updateListeners();\r\n  }\r\n\r\n  getAllSegments(): TranscriptSegment[] {\r\n    return [...this.segments];\r\n  }\r\n}\r\n\r\nexport const transcriptService = new TranscriptService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}